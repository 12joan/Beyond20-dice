from utils import addCustomEventListener
from settings import WhisperType
from roll_renderer import Beyond20RollRenderer

settings = None
extension_url = "/modules/beyond20/"

class FVTTDisplayer:
    def postHTML(self, request, title, html, buttons, play_sound):
        Hooks.once('renderChatMessage', def(chat_message, data, html):
                    nonlocal extension_url
                    icon16 = extension_url + "images/icons/icon16.png"
                    html.find(".ct-beyond20-custom-icon").attr('src', icon16)
                    html.find(".ct-beyond20-custom-roll").on('click', def(event):
                        nonlocal roll_renderer
                        roll = $(event.currentTarget).find(".beyond20-roll-formula").text()
                        roll_renderer.rollDice(request, title, roll)
                    )
                    html.find(".beyond20-chat-button").on('click', def(event):
                        button = $(event.currentTarget).text()
                        buttons[button]()
                    )
                )
        return self._postChatMessage(html, request.character.name, request.whisper, play_sound)

    def _postChatMessage(self, message, character, whisper, play_sound=False):
        nonlocal CHAT_MESSAGE_TYPES
        # Prior to 0.3.6, CHAT_MESSAGE_TYPES wasn't defined
        MESSAGE_TYPES = {"OOC": 1, "WHISPER": 4}
        if CHAT_MESSAGE_TYPES?:
            MESSAGE_TYPES = {"OOC": CHAT_MESSAGE_TYPES.OOC, "WHISPER": CHAT_MESSAGE_TYPES.WHISPER}
        data = {"content": message, 
                "user": game.user._id,
                "speaker": self._getSpeakerByName(character)}
        rollMode = self._whisperToRollMode(whisper)
        if rollMode in ["gmroll", "blindroll"]:
            data['type'] = MESSAGE_TYPES.WHISPER
            data["whisper"] = ChatMessage.getWhisperIDs("GM")
            if rollMode == "blindroll":
                data["blind"] = True
        else:
            data['type'] = MESSAGE_TYPES.OOC
        if play_sound:
            data["sound"] = CONFIG.sounds.dice
        return ChatMessage.create(data)

    def _getSpeakerByName(self, name):
        if name is None:
            return ChatMessage.getSpeaker()
        low_name = name.toLowerCase()
        actor = game.actors.entities.find(def(actor): return actor.data.name.toLowerCase() == low_name;)
        speaker = ChatMessage.getSpeaker({"actor": actor})
        speaker["alias"] = name
        return speaker

    def _whisperToRollMode(self, whisper):
        try:
            return {WhisperType.NO: "roll",
                    WhisperType.YES: "gmroll",
                    WhisperType.QUERY: game.settings.get("core", "rollMode")
                    }[whisper]
        except:
            return game.settings.get("core", "rollMode")


class FVTTRoll:
    def __init__(self, formula, data={}):
        formula = formula.replace("ro<2", "r<=2")
        self._roll = new Roll(formula, data).roll()
        self._fail_limit = None
        self._critical_limit = None

    @property
    def total(self):
        return self._roll.total
    @property
    def formula(self):
        return self._roll.formula
    @property
    def dice(self):
        return self._roll.dice

    def getTooltip(self):
        return self._roll.getTooltip()

    def reroll(self):
        self._roll = self._roll.reroll()
        return self

    def setCriticalLimit(self, limit):
        self._critical_limit = limit
    def setFailLimit(self, limit):
        self._fail_limit = limit

    def checkRollForCrits(self, roll, cb):
        for die in roll.dice:
            for r in die.rolls:
                if not (r.discarded ? False):
                    if cb(die.faces, r.roll):
                        return True
        return False

    def isCriticalHit(self):
        return self.checkRollForCrits(self._roll, def(faces, value):
            limit = faces if self._critical_limit is None else self._critical_limit
            return value >= limit
        )

    def isCriticalFail(self):
        return self.checkRollForCrits(self._roll, def(faces, value):
            limit = 1 if self._critical_limit is None else self._fail_limit
            return value <= limit
        )

class FVTTRoller:
    def roll(self, formula, data):
        return FVTTRoll(formula, data)

    def reroll(self, roll):
        return roll.reroll()

class FVTTPrompter:
    def prompt(self, title, html, ok_label="OK", cancel_label="Cancel"):
        return new Promise(def(resolve, reject):
            nonlocal extension_url
            icon = '<img style="border: 0px;" src="' + extension_url + "images/icons/icon16.png" + '"></img>'
            ok_pressed = False
            new Dialog({"title": title,
                        "content": html,
                        "buttons": {"ok": {"label": ok_label,
                                            "icon": icon,
                                            "callback": def():
                                                nonlocal ok_pressed
                                                ok_pressed = True
                                            
                                        },
                                    "cancel": {"label": cancel_label}
                                    },
                        "default": "ok",
                        "close": def(html):
                            resolve(html if ok_pressed else None)
                        }).render(True)
        )

roll_renderer = Beyond20RollRenderer(FVTTRoller(), FVTTPrompter(), FVTTDisplayer())
roll_renderer.setBaseURL(extension_url)
roll_renderer.setSettings(settings)

def rollInitiative(request, custom_roll_dice=""):
    nonlocal settings, roll_renderer

    roll_renderer.handleRollRequest(request).then(def(roll):
        if settings["initiative-tracker"]:
            addInitiativeToCombat(roll)
    )

v'async'
def addInitiativeToCombat(roll):
    if canvas.tokens.controlledTokens.length > 0:
        if game.combat?:
            if game.combat.scene.id != canvas.scene.id:
                ui.notifications.warn("Cannot add initiative to tracker: Encounter was not created for this scene")
            else:
                for token in canvas.tokens.controlledTokens:
                    combatant = game.combat.getCombatantByToken(token.id)
                    if combatant:
                        promise = game.combat.updateCombatant({"id": combatant.id, "initiative": roll.total})
                    else:
                        promise = game.combat.createCombatant({"tokenId": token.id, "hidden": token.data.hidden, "initiative": roll.total})
                    # to avoid a 'defined but not used' 
                    promise
                    v'await promise'
        else:
            ui.notifications.warn("Cannot add initiative to tracker: no Encounter has been created yet")
    else:
            ui.notifications.warn("Cannot add initiative to tracker: no token is currently selected")



def handleRoll(request):
    nonlocal roll_renderer

    console.log("Received roll request ", request)

    if request.type == "initiative":
        rollInitiative(request)
    else:
        roll_renderer.handleRollRequest(request)

def updateHP(name, current, total=None):
    console.log("Updating HP for " + name + " : " + current + "/" + total)
    name = name.toLowerCase()

    tokens = canvas.tokens.objects.children.filter(def(t): return t.data.name.toLowerCase() == name;)

    if len(tokens) == 0:
        actor = game.actors.entities.find(def(a):
                                                 return a.permission == ENTITY_PERMISSIONS.OWNER and \
                                                     a.data.name.toLowerCase() == name
                                             )
        if actor?:
            actor.update({"data.attributes.hp.value" : current,
                          "data.attributes.hp.max" : total})

    for token in tokens:
        if token.actor and token.data.actorLink:
            total = total if total else token.actor.data.attributes.hp.max
            token.actor.update({"data.attributes.hp.value" : current,
                                "data.attributes.hp.max" : total})
        else:
            if token.data.bar1.attribute == "attributes.hp":
                prefix = "bar1"
                total = total if total else token.data.bar1.max
            elif token.data.bar2.attribute == "attributes.hp":
                prefix = "bar2"
                total = total if total else token.data.bar2.max
            else:
                prefix = None
            if prefix:
                token.update(canvas.id, {prefix + ".value": current,
                                         prefix + ".max": total})
def setSettings(new_settings, url):
    nonlocal settings, extension_url, roll_renderer

    settings = new_settings
    extension_url = url
    roll_renderer.setBaseURL(extension_url)
    roll_renderer.setSettings(settings)

def disconnectAllEvents():
    nonlocal registered_events
    
    for event in registered_events:
        document.removeEventListener(*event)

def setTitle():
    if game.world?:
        title = document.getElementsByTagName("title")[0]
        # Make sure the mutation gets triggerred if we reload the extension
        title.textContent = "Foundry Virtual Tabletop"
        title.textContent = game.world.title + " â€¢ Foundry Virtual Tabletop"
    else:
        # Wait a second for the world to get loaded
        setTimeout(setTitle, 1000)

console.log("Beyond20: FVTT Page Script loaded")
registered_events = []
registered_events.append(addCustomEventListener("Roll", handleRoll))
registered_events.append(addCustomEventListener("NewSettings", setSettings))
registered_events.append(addCustomEventListener("UpdateHP", updateHP))
registered_events.append(addCustomEventListener("disconnect", disconnectAllEvents))
setTitle()