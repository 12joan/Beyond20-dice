from utils import addCustomEventListener, injectCSS, replaceRolls
from settings import WhisperType, RollType
from constants import FVTT_CSS
import math

settings = None
extension_url = "/modules/beyond20/"

def getSpeakerByName(name):
    low_name = name.toLowerCase()
    actor = game.actors.entities.find(def(actor): return actor.data.name.toLowerCase() == low_name;)
    speaker = ChatMessage.getSpeaker({"actor": actor})
    speaker["alias"] = name
    return speaker

def whisperToRollMode(whisper):
    try:
        return {WhisperType.NO: "roll",
                WhisperType.YES: "gmroll",
                WhisperType.QUERY: game.settings.get("core", "rollMode")
                }[whisper]
    except:
        return game.settings.get("core", "rollMode")

v'async'
def queryAdvantage(title):
    nonlocal extension_url
    icon = '<img style="border: 0px;" src="' + extension_url + "images/icons/icon16.png" + '"></img>'

    return new Promise(def(resolve, reject):
                           adv = 0
                           new Dialog({"title": title,
                             "content": "Choose roll mode for : " + title,
                             "buttons": {"advantage": {"label": "Advantage",
                                                       "icon": icon,
                                                       "callback": def():
                                                           nonlocal adv
                                                           adv = 1
                                                       },
                                         "normal": {"label": "Normal",
                                                    "icon": icon},
                                         "disadvantage": {"label": "Disadvantage",
                                                          "icon": icon,
                                                          "callback": def():
                                                              nonlocal adv
                                                              adv = -1
                                                          }
                                         },
                                       "default": "normal",
                                       "close": def(html):
                                           nonlocal adv
                                           resolve(adv)
                                       }).render(True)
                       )

def postChatMessage(message, character, whisper):
    data = {"content": message, 
            "user": game.user._id,
            "speaker": getSpeakerByName(character)}
    rollMode = whisperToRollMode(whisper)
    if rollMode in ["gmroll", "blindroll"]:
        data["whisper"] = ChatMessage.getWhisperIDs("GM")
        if rollMode == "blindroll":
            data["blind"] = True
    return ChatMessage.create(data)

def postRoll(roll, character, title, whisper):
    rollMode = whisperToRollMode(whisper)
    roll.toMessage({"speaker": getSpeakerByName(character),
                    "flavor": title,
                    "rollMode": rollMode})
    return roll

def checkRollForCrits(roll, cb):
    for die in roll.dice:
        for r in die.rolls:
            if not (r.discarded ? False):
                if cb(die.faces, r.roll):
                    return True
    return False

def isCriticalHit(roll):
    return checkRollForCrits(roll, def(faces, value): return value == faces;)

def isCriticalFail(roll):
    return checkRollForCrits(roll, def(faces, value): return value == 1;)

def isCriticalHitD20(rolls, limit=20):
    for roll in rolls:
        if checkRollForCrits(roll, def(faces, value): return faces == 20 and value >= limit;):
            return True
    return False

def injectRollsInDescription(description):
    icon16 = "/modules/beyond20/images/icons/icon16.png"
    replaceCB = def(dice, modifier):
        dice_formula = ("1d20" if dice == "" else dice) + modifier
        # <u> is filtered out in 0.3.2, so using <span> instead
        return '<span class="ct-beyond20-custom-roll"><strong>' + dice + modifier + '</strong>' + \
            '<img class="ct-beyond20-custom-icon" src="' + icon16 + \
            '" style="margin-right: 3px; margin-left: 3px; border: 0px;"></img>' + \
            '<span class="beyond20-roll-formula" style="display: none;">' + dice_formula + '</span></span>'
    return replaceRolls(description, replaceCB)

v'async'
def rollToDetails(roll):
    hit = isCriticalHit(roll)
    fail = isCriticalFail(roll)
    color = 'blue' if hit and fail else ('green' if hit else ('red' if fail else 'black'))
    tooltip = v'await roll.getTooltip()'
    return "<span class='beyond20-tooltip' style='color: " + color + ";'>" + roll.total + "<span class='dice-roll beyond20-tooltip-content'>" + \
        "<div class='dice-formula'>" + roll.formula + "</div>" + tooltip + "</span></span>"

def rollsToCells(html):
    result = ""
    for roll in html.split(" | "):
        result += '<div class="beyond20-roll-cell">' + roll + '</div>'
    return result


v'async'
def postDescription(request, title, source, attributes, description, rolls=[], buttons={}, open=False):
    html = '<div class="beyond20-message">'
    if description:
        html += "<details" + (" open" if open else "") + "><summary><a>" + title + "</a></summary>"
        if source or attributes.length > 0:
            html += "<table>"
            if source:
                html += "<tr><td colspan'2'><i>" + source + "</i></td></tr>"
            for attr in attributes:
                html += "<tr><td><b>" + attr + "</b></td><td>" + attributes[attr] + "</td></tr>"
            html += "</table>"
        description = injectRollsInDescription(description).replace("\n", "</br>")
        html += "<div class='beyond20-description'>" + description + "</div></details>"
    else:
        html = "<div class='beyond20-title'>" + title + "</div>"

    console.log("Rolls : ", rolls)
    for (roll_name, roll) in rolls:
        if isinstance(roll, str):
            roll_html = "<span>" + roll + "</span>"
        else:
            if isinstance(roll, list):
                roll_list = roll
                roll_html = ""
                for i, roll in enumerate(roll_list):
                    if i > 0:
                        roll_html += " | "
                    roll_html += v'await rollToDetails(roll)'
            else:
                roll_html = v'await rollToDetails(roll)'
        if roll_name:
            roll_name = roll_name[0].toUpperCase() + roll_name[1:] + (": " if roll_html else "")
            html += "<div class='beyond20-roll-result'><b>" + roll_name + "</b>" + roll_html + "</div>"
        else:
            html += "<div class='beyond20-roll-result beyond20-roll-cells'>" + rollsToCells(roll_html) + "</div>"

    for button in buttons:
        html += '<button class="beyond20-chat-button">' + button + '</button>'
    html += "</div>"

    Hooks.once('renderChatMessage', def(chat_message, data, html):
                   nonlocal extension_url
                   icon16 = extension_url + "images/icons/icon16.png"
                   html.find(".ct-beyond20-custom-icon").attr('src', icon16)
                   html.find(".ct-beyond20-custom-roll").on('click', def(event):
                                                                roll = $(event.currentTarget).find(".beyond20-roll-formula").text()
                                                                rollDice(request, title, roll)
                                                            )
                   html.find(".beyond20-chat-button").on('click', def(event):
                                                             button = $(event.currentTarget).text()
                                                             buttons[button]()
                                                         )
               )
    return postChatMessage(html, request.character.name, request.whisper)

def createRoll(dice, data):
    new_data = {}
    parts = [dice]
    for key in data:
        if data[key] != "":
            new_key = key.replace("_", "").toLowerCase()
            new_data[new_key] = data[key]
            parts.append(new_key)
    return new Roll(parts.join(" + @"), new_data)

def rollDice(request, title, dice, data={}):
    roll = createRoll(dice, data)
    return postRoll(roll, request.character.name, title, request.whisper)

v'async'
def rollD20(request, title, data):
    if request.advantage == RollType.NORMAL:
        dice = "1d20"
    elif request.advantage == RollType.ADVANTAGE:
        dice = "2d20kh"
    elif request.advantage == RollType.DISADVANTAGE:
        dice = "2d20kl"
    elif request.advantage == RollType.DOUBLE:
        dice = "1d20"
        roll_1 = createRoll(dice, data).roll()
        roll_2 = createRoll(dice, data).roll()
        console.log("Rolls :", roll_1, roll_2)
        postDescription(request, title, None, {}, None, rolls=[(None, [roll_1, roll_2])])
        return roll_1
    else:
        adv = v'await queryAdvantage(title)'
        dice = "1d20" if adv == 0 else ("2d20" + ("kh" if adv == 1 else "kl"))

    return rollDice(request, title, dice, data)
    
def rollSkill(request, custom_roll_dice=""):
    data = {request.ability: request.modifier, "custom_dice": custom_roll_dice}

    # Custom skill
    if request.modifier == "--" and request.character.abilities.length > 0:
        nonlocal extension_url
        icon = '<img style="border: 0px;" src="' + extension_url + "images/icons/icon16.png" + '"></img>'

        prof = ""
        prof_val = ""
        if request.proficiency == "Proficiency":
            prof = "proficiency"
            prof_val = request.character.proficiency
        elif request.proficiency == "Half Proficiency":
            prof = "half_proficiency"
            prof_val += math.floor(request.character.proficiency / 2)
        elif request.proficiency == "Expertise":
            prof = "expertise"
            prof_val += request.character.proficiency * 2
        formula = "1d20 + @ability " + ((" + @" + prof) if prof != "" else prof) + " + @custom_dice"
        html = '<form>'
        html += '<div class="form-group"><label>Roll Formula</label><input type="text" value="' + formula + '" disabled></div>'
        html += '<div class="form-group"><label>Select Ability</label><select name="ability">'
        modifiers = {}
        for ability in request.character.abilities:
            html += '<option value="' + ability[0] + '">' + ability[0] + '</option>'
            modifiers[ability[0]] = ability[3]
        html += "</select></div>"
        html += '</form>'
        new Dialog({"title": "Custom Skill",
                    "content": html,
                    "buttons": {"ok": {"label": request.skill,
                                       "icon": icon}},
                    "default": "ok",
                    "close": def(html):
                        ability = html.find('[name="ability"]').val()
                        mod = modifiers[ability]
                        console.log("Modifier : ", mod)
                        data = {"ability": mod, "prof": prof_val, "custom_dice": custom_roll_dice}
                        rollD20(request, request.skill + "(" + ability + ")", data)
                    }).render(True)
    else:
        rollD20(request, request.skill + "(" + request.modifier + ")", data)

def rollAbility(request, custom_roll_dice=""): 
    data = {request.ability: request.modifier, "custom_dice": custom_roll_dice}
    rollD20(request, request.name + "(" + request.modifier + ")", data)

def rollSavingThrow(request, custom_roll_dice=""):
    data = {request.ability: request.modifier, "custom_dice": custom_roll_dice}
    rollD20(request, request.name + " Save" + "(" + request.modifier + ")", data)
  
def rollInitiative(request, custom_roll_dice=""):
    nonlocal settings

    data = {"initiative": request.initiative, "custom_dice": custom_roll_dice}
    rollD20(request, "Initiative" + "(" + request.initiative + ")", data).then(def(roll):
        if settings["initiative-tracker"]:
            if canvas.tokens.controlledTokens.length > 0:
                if game.combat?:
                    for token in canvas.tokens.controlledTokens:
                        game.combat.createCombatant({"tokenId": token.id, "hidden": token.data.hidden, "initiative": roll.total})
                else:
                    ui.notifications.warn("Cannot add initiative to tracker: no Encounter has been created yet")
            else:
                    ui.notifications.warn("Cannot add initiative to tracker: no token is currently selected")
    )

def rollHitDice(request):
    rname = "Hit Dice" + (("(" + request.class + ")") if  request.multiclass else "")
    rollDice(request, rname, request["hit-dice"], {})

def rollDeathSave(request, custom_roll_dice=""):
    rollD20(request, "Death Saving Throw", {"custom_dice": custom_roll_dice})

def rollTrait(request):
    if request["source-type"]?:
        source = request["source-type"]
        if request.source.length > 0:
            source += ": " + request.source
    elif request["item-type"]?:
        source = request["item-type"]
    else:
        source = request.type

    postDescription(request, request.name, source, {}, request.description, open=True)

v'async'
def buildAttackRolls(request, custom_roll_dice):
    rolls = []
    damage_rolls = []
    is_critical = False
    if request["to-hit"]?:
        critical_limit = 20
        if request["attack-source"] == "item":
            if request.character.type == "Character" and \
                    "Improved Critical" in request.character["class-features"]:
                critical_limit = 19
            if request.character.type == "Character" and \
                    "Superior Critical" in request.character["class-features"]:
                critical_limit = 18

        custom = "" if custom_roll_dice == "" else (" + " + custom_roll_dice)
        to_hit = " + " + request["to-hit"] + custom

        if request.advantage == RollType.DOUBLE:
            roll_1 = new Roll("1d20" + to_hit).roll()
            roll_2 = new Roll("1d20" + to_hit).roll()
            to_hit_roll = [roll_1, roll_2]
            is_critical = isCriticalHitD20(to_hit_roll, critical_limit)
        else:
            if request.advantage == RollType.NORMAL:
                dice = "1d20"
            elif request.advantage == RollType.ADVANTAGE:
                dice = "2d20kh"
            elif request.advantage == RollType.DISADVANTAGE:
                dice = "2d20kl"
            else:
                adv = v'await queryAdvantage(request.name)'
                dice = "1d20" if adv == 0 else ("2d20" + ("kh" if adv == 1 else "kl"))
            to_hit_roll = new Roll(dice + to_hit).roll()
            is_critical = isCriticalHitD20([to_hit_roll], critical_limit)
        rolls.append((None, to_hit_roll))

    if request.damages?:
        damages = list(request.damages)
        damage_types = list(request["damage-types"])
        has_versatile = len(damage_types) > 1 and damage_types[1] == "Two-Handed"
        total_damage = ""
        total_versatile_damage = ""
        for i in range(damages.length):
            roll = new Roll(damages[i]).roll()
            if (not has_versatile) or i != 1:
                total_damage += ("" if i == 0 else " + ") + str(roll.total)
            if has_versatile and i != 0:
                total_versatile_damage += ("" if i == 1 else " + ") + str(roll.total)
            dmg_type = damage_types[i]
            suffix = " Damage" if dmg_type not in ["Healing", "Disciple of Life"] else ""
            damage_rolls.append((dmg_type + suffix, roll))

    if is_critical and request["critical-damages"]?:
        damages = list(request["critical-damages"])
        damage_types = list(request["critical-damage-types"])
        total_critical_damage = ""
        total_critical_versatile_damage = ""
        for i in range(damages.length):
            roll = new Roll(damages[i]).roll()
            if (not has_versatile) or i != 1:
                total_critical_damage += ("" if i == 0 else " + ") + str(roll.total)
            if has_versatile and i != 0:
                total_critical_versatile_damage += ("" if i == 1 else " + ") + str(roll.total)
            dmg_type = damage_types[i]
            suffix = " Critical Damage" if dmg_type not in ["Healing", "Disciple of Life"] else ""
            damage_rolls.append((dmg_type + suffix, roll))

    if total_damage? and "+" in total_damage:
        damage_rolls.append(("------", []))
        damage_rolls.append(("Total Damage", new Roll(total_damage).roll()))
        if total_versatile_damage != "":
            damage_rolls.append(("Total Two-Handed Damage", new Roll(total_versatile_damage).roll()))
        if total_critical_damage?:
            damage_rolls.append(("Total Critical Damage", new Roll(total_critical_damage).roll()))
            if total_critical_versatile_damage != "":
                damage_rolls.append(("Total Critical Two-Handed Damage", new Roll(total_critical_versatile_damage).roll()))

    return [rolls, damage_rolls]

v'async'
def rollAttack(request, custom_roll_dice=""):
    nonlocal settings

    [rolls, damage_rolls] = v'await buildAttackRolls(request, custom_roll_dice)'

    data = {}
    if request.range?:
        data["Range"] = request.range

    if request["save-dc"]?:
        rolls.append(("Save", request["save-ability"] + " DC " + request["save-dc"]))

    if len(damage_rolls) > 0 and len(rolls) > 0 and not settings["auto-roll-damage"]:
        cb = def():
            postDescription(request, request.name, None, data, request.description? "", damage_rolls)
        postDescription(request, request.name, None, data, request.description? "", rolls, buttons={"Roll Damages" : cb})
    else:
        postDescription(request, request.name, None, data, request.description? "", rolls.concat(damage_rolls))



def buildSpellCard(request):
    data = {"Casting Time": request["casting-time"],
            "Range": request.range,
            "Duration": request.duration,
            "Components": request.components}

    if request["cast-at"]?:
        source = request["level-school"] + "(Cast at " + request["cast-at"] + " Level)"
    else:
        source = request["level-school"]
                                                    
    
    if request.ritual:
        data["Ritual"] = "Can be cast as a ritual"
    if request.concentration:
        data["Concentration"] = "Requires Concentration"
    description = request.description.replace("At Higher Levels.", "</br><b>At Higher levels.</b>")

    return (source, data, description)

def rollSpellCard(request):
    spell_card = buildSpellCard(request)
    postDescription(request, request.name, spell_card[0], spell_card[1], spell_card[2], open=True)

v'async'
def rollSpellAttack(request, custom_roll_dice):
    nonlocal settings

    spell_card = buildSpellCard(request)

    rolls = []
    if request.range?:
        rolls.append(("Range", request.range))

    if request["cast-at"]?:
        rolls.append(("Cast at", request["cast-at"] + " Level"))
    components = request.components
    prefix = settings["component-prefix"] if settings["component-prefix"] != "" else None
    if settings["components-display"] == "all":
        if components != "":
            rolls.append((prefix or "Components", components))
    elif settings["components-display"] == "material":
        while components != "":
            if components[0] in ["V", "S"]:
                components = components[1:]
                if components.startsWith(", "):
                    components = components[2:]
            if components[0] == "M":
                rolls.append((prefix or "Materials", settings["component-prefix"] + components[2:-1]))
                components = ""

    if request["save-dc"]?:
        rolls.append(("Save", request["save-ability"] + " DC " + request["save-dc"]))

    [attack_rolls, damage_rolls] = v'await buildAttackRolls(request, custom_roll_dice)'
    rolls.extend(attack_rolls)

    if len(damage_rolls) > 0 and len(attack_rolls) > 0 and not settings["auto-roll-damage"]:
        cb = def():
            postDescription(request, request.name, spell_card[0], spell_card[1], spell_card[2], damage_rolls)
        postDescription(request, request.name, spell_card[0], spell_card[1], spell_card[2], rolls, buttons={"Roll Damages" : cb})
    else:
        postDescription(request, request.name, spell_card[0], spell_card[1], spell_card[2], rolls.concat(damage_rolls))

def handleRoll(request):
    nonlocal settings

    console.log("Received roll request ", request)

    custom_roll_dice = ""
    if request.character.type == "Character":
        custom_roll_dice = request.character.settings["custom-roll-dice"] ? ""
    if request.type == "skill":
        rollSkill(request, custom_roll_dice)
    elif request.type == "ability":
        rollAbility(request, custom_roll_dice)
    elif request.type == "saving-throw":
        rollSavingThrow(request, custom_roll_dice)
    elif request.type == "initiative":
        rollInitiative(request, custom_roll_dice)
    elif request.type == "hit-dice":
        rollHitDice(request)
    elif request.type in ["item", "feature", "trait", "action"]:
        rollTrait(request)
    elif request.type == "death-save":
        rollDeathSave(request, custom_roll_dice)
    elif request.type == "attack":
        rollAttack(request, custom_roll_dice)
    elif request.type == "spell-card":
        rollSpellCard(request)
    elif request.type == "spell-attack":
        rollSpellAttack(request, custom_roll_dice)
    else:
        # 'custom' or anything unexpected
        mod = request.modifier if request.modifier? else request.roll
        rname = request.name if request.name? else request.type

        rollDice(request, rname + "(" + mod + ")", mod, {})

def updateHP(name, current, total=None):
    console.log("Updating HP for " + name + " : " + current + "/" + total)
    name = name.toLowerCase()

    tokens = canvas.tokens.objects.children.filter(def(t): return t.data.name.toLowerCase() == name;)

    if len(tokens) == 0:
        actor = game.actors.entities.find(def(a):
                                                 return a.permission == ENTITY_PERMISSIONS.OWNER and \
                                                     a.data.name.toLowerCase() == name
                                             )
        if actor?:
            actor.update({"data.attributes.hp.value" : current,
                          "data.attributes.hp.max" : total})

    for token in tokens:
        if token.actor and token.data.actorLink:
            total = total if total else token.actor.data.attributes.hp.max
            token.actor.update({"data.attributes.hp.value" : current,
                                "data.attributes.hp.max" : total})
        else:
            if token.data.bar1.attribute == "attributes.hp":
                prefix = "bar1"
                total = total if total else token.data.bar1.max
            elif token.data.bar2.attribute == "attributes.hp":
                prefix = "bar2"
                total = total if total else token.data.bar2.max
            else:
                prefix = None
            if prefix:
                token.update(canvas.id, {prefix + ".value": current,
                                         prefix + ".max": total})
def setSettings(new_settings, url):
    nonlocal settings, extension_url
    settings = new_settings
    extension_url = url

def disconnectAllEvents():
    nonlocal registered_events
    
    for event in registered_events:
        document.removeEventListener(*event)

def setTitle():
    if game.world?:
        title = document.getElementsByTagName("title")[0]
        # Make sure the mutation gets triggerred if we reload the extension
        title.textContent = "Foundry Virtual Tabletop"
        title.textContent = game.world.name + " • Foundry Virtual Tabletop"
    else:
        # Wait a second for the world to get loaded
        setTimeout(setTitle, 1000)

console.log("Beyond20: FVTT Page Script loaded")
injectCSS(FVTT_CSS)
registered_events = []
registered_events.append(addCustomEventListener("Roll", handleRoll))
registered_events.append(addCustomEventListener("NewSettings", setSettings))
registered_events.append(addCustomEventListener("UpdateHP", updateHP))
registered_events.append(addCustomEventListener("disconnect", disconnectAllEvents))
setTitle()
