from utils import addCustomEventListener, injectCSS, replaceRolls
from settings import WhisperType, RollType
from constants import FVTT_CSS

settings = None
extension_url = "/public/modules/beyond20/"

def getSpeakerByName(name):
    low_name = name.toLowerCase()
    actor = game.actors.entities.find(def(actor): return actor.data.name.toLowerCase() == low_name;)
    speaker = ChatMessage.getSpeaker({"actor": actor})
    speaker["alias"] = name
    return speaker

def whisperToRollMode(whisper):
    try:
        return {WhisperType.NO: "roll",
                WhisperType.YES: "gmroll",
                WhisperType.QUERY: game.settings.get("core", "rollMode")
                }[whisper]
    except:
        return game.settings.get("core", "rollMode")

def postChatMessage(message, character, whisper):
    data = {"content": message, 
            "user": game.user._id,
            "speaker": getSpeakerByName(character)}
    rollMode = whisperToRollMode(whisper)
    if rollMode in ["gmroll", "blindroll"]:
        data["whisper"] = ChatMessage.getWhisperIDs("GM")
        if rollMode == "blindroll":
            data["blind"] = True
    return ChatMessage.create(data)

def postRoll(roll, character, title, whisper):
    rollMode = whisperToRollMode(whisper)
    roll.toMessage({"speaker": getSpeakerByName(character),
                    "flavor": title,
                    "rollMode": rollMode})
    return roll

def checkRollForCrits(roll, cb):
    for die in roll.dice:
        for r in die.rolls:
            if not (r.discarded ? False):
                if cb(die.faces, r.roll):
                    return True
    return False

def isCriticalHit(roll):
    return checkRollForCrits(roll, def(faces, value): return value == faces;)

def isCriticalFail(roll):
    return checkRollForCrits(roll, def(faces, value): return value == 1;)

def isCriticalHitD20(rolls, limit=20):
    for roll in rolls:
        if checkRollForCrits(roll, def(faces, value): return faces == 20 and value >= limit;):
            return True
    return False

def injectRollsInDescription(description):
    nonlocal extension_url
    icon16 = extension_url + "images/icons/icon16.png"
    replaceCB = def(dice, modifier):
        dice_formula = ("1d20" if dice == "" else dice) + modifier
        # <u> is filtered out in 0.3.2, so using <span> instead
        return '<span class="ct-beyond20-custom-roll"><strong>' + dice + modifier + '</strong>' + \
            '<img class="ct-beyond20-custom-icon" src="' + icon16 + \
            '" style="margin-right: 3px; margin-left: 3px;"></img>' + \
            '<span class="beyond20-roll-formula" style="display: none;">' + dice_formula + '</span></span>'
    return replaceRolls(description, replaceCB)

v'async'
def rollToDetails(roll):
    hit = isCriticalHit(roll)
    fail = isCriticalFail(roll)
    color = 'blue' if hit and fail else ('green' if hit else ('red' if fail else 'black'))
    tooltip = v'await roll.getTooltip()'
    return "<span class='beyond20-tooltip' style='color: " + color + ";'>" + roll.total + "<span class='dice-roll beyond20-tooltip-content'>" + \
        "<div class='dice-formula'>" + roll.formula + "</div>" + tooltip + "</span></span>"

v'async'
def postDescription(request, title, source, attributes, description, rolls=[], open=False):
    style = "margin: 2px 0px; border: 1px solid #333; width: 100%; border-spacing: 0; border-collapse: collapse; background-color: #DDD;"

    if description:
        html = "<details" + (" open" if open else "") + "><summary><a><font style='color: #A00; font-size: 1.25em;'>" + title + "</font></a></summary>"
        if source or attributes.length > 0:
            html += "<table style='" + style + "'>"
            if source:
                html += "<tr><td colspan'2'><i>" + source + "</i></td></tr>"
            for attr in attributes:
                html += "<tr><td><b>" + attr + "</b></td><td>" + attributes[attr] + "</td></tr>"
            html += "</table>"
        description = injectRollsInDescription(description).replace("\n", "</br>")
        html += "<div style='" + style + "'>" + description + "</div></details>"
    else:
        html = "<div style='" + style + "'>" + title + "</div>"

    console.log("Rolls : ", rolls)
    for (roll_name, roll) in rolls:
        if roll_name:
            roll_name = roll_name[0].toUpperCase() + roll_name[1:] + ": "
        else:
            roll_name = ""
        if isinstance(roll, str):
            roll_html = "<span>" + roll + "</span>"
        else:
            if isinstance(roll, list):
                roll_list = roll
                roll_html = ""
                for i, roll in enumerate(roll_list):
                    if i > 0:
                        roll_html += " | "
                    roll_html += v'await rollToDetails(roll)'
            else:
                roll_html = v'await rollToDetails(roll)'
        html += "<div class='beyond20-roll-result'><b>" + roll_name + "</b>" + roll_html + "</div>"

    Hooks.once('renderChatMessage', def(chat_message, data, html):
                   console.log("chat message rendered : ", html)
                   html.find(".ct-beyond20-custom-roll").on('click', def(event):
                                                                console.log("clicked!")
                                                                roll = $(event.currentTarget).find(".beyond20-roll-formula").text()
                                                                console.log("Formula : ", roll)
                                                                rollDice(request, title, roll)
                                                            )
               )
    return postChatMessage(html, request.character.name, request.whisper)

def createRoll(dice, data):
    new_data = {}
    parts = [dice]
    for key in data:
        if data[key] != "":
            new_key = key.replace("_", "").toLowerCase()
            new_data[new_key] = data[key]
            parts.append(new_key)
    return new Roll(parts.join(" + @"), new_data)

def rollDice(request, title, dice, data={}):
    roll = createRoll(dice, data)
    return postRoll(roll, request.character.name, title, request.whisper)

v'async'
def rollD20(request, title, data):
    if request.advantage == RollType.NORMAL:
        dice = "1d20"
    elif request.advantage == RollType.ADVANTAGE:
        dice = "2d20kh"
    elif request.advantage == RollType.DISADVANTAGE:
        dice = "2d20kl"
    elif request.advantage == RollType.DOUBLE:
        dice = "1d20"
        roll_1 = createRoll(dice, data).roll()
        roll_2 = createRoll(dice, data).roll()
        console.log("Rolls :", roll_1, roll_2)
        postDescription(request, title, None, {}, None, rolls=[(None, [roll_1, roll_2])])
        return Promise.resolve(roll_1)
    else:
        dice = "1d20" # TODO: query dialog
        return new Promise(def(resolve, reject):
                               adv = 0
                               new Dialog({"title": title,
                                 "content": "Choose roll mode for : " + title,
                                 "buttons": {"advantage": {"label": "Advantage",
                                                           "callback": def():
                                                               nonlocal adv
                                                               adv = 1
                                                           },
                                             "normal": {"label": "Normal"},
                                             "disadvantage": {"label": "Disadvantage",
                                                              "callback": def():
                                                                  nonlocal adv
                                                                  adv = -1
                                                              }
                                             },
                                           "default": "normal",
                                           "close": def(html):
                                               nonlocal adv
                                               dice = "1d20" if adv == 0 else ("2d20" + ("kh" if adv == 1 else "kl"))
                                               resolve(rollDice(request, title, dice, data))
                                           }).render(True)
                           )

    return Promise.resolve(rollDice(request, title, dice, data))
    
def rollSkill(request, custom_roll_dice=""):
    data = {request.ability: request.modifier, "custom_dice": custom_roll_dice}
    # TODO: if modifier == "--": Query ability.
    rollD20(request, request.skill + "(" + request.modifier + ")", data)

def rollAbility(request, custom_roll_dice=""): 
    data = {request.ability: request.modifier, "custom_dice": custom_roll_dice}
    rollD20(request, request.name + "(" + request.modifier + ")", data)

def rollSavingThrow(request, custom_roll_dice=""):
    data = {request.ability: request.modifier, "custom_dice": custom_roll_dice}
    rollD20(request, request.name + " Save" + "(" + request.modifier + ")", data)
  
def rollInitiative(request, custom_roll_dice=""):
    nonlocal settings

    data = {"initiative": request.initiative, "custom_dice": custom_roll_dice}
    rollD20(request, "Initiative" + "(" + request.initiative + ")", data).then(def(roll):
        if settings["initiative-tracker"]:
            if canvas.tokens.controlledTokens.length > 0:
                if game.combat?:
                    for token in canvas.tokens.controlledTokens:
                        game.combat.createCombatant({"tokenId": token.id, "hidden": token.data.hidden, "initiative": roll.total})
                else:
                    ui.notifications.warn("Cannot add initiative to tracker: no Encounter has been created yet")
            else:
                    ui.notifications.warn("Cannot add initiative to tracker: no token is currently selected")
    )

def rollHitDice(request):
    rname = "Hit Dice" + (("(" + request.class + ")") if  request.multiclass else "")
    rollDice(request, rname, request["hit-dice"], {})

def rollDeathSave(request, custom_roll_dice=""):
    rollD20(request, "Death Saving Throw", {"custom_dice": custom_roll_dice})

def rollTrait(request):
    if request["source-type"]?:
        source = request["source-type"]
        if request.source.length > 0:
            source += ": " + request.source
    elif request["item-type"]?:
        source = request["item-type"]
    else:
        source = request.type

    postDescription(request, request.name, source, {}, request.description, open=True)

def buildAttackRolls(request, custom_roll_dice):
    rolls = []
    is_critical = False
    if request["to-hit"]?:
        critical_limit = 20
        if request["attack-source"] == "item":
            if request.character.type == "Character" and \
                    "Improved Critical" in request.character["class-features"]:
                critical_limit = 19
            if request.character.type == "Character" and \
                    "Superior Critical" in request.character["class-features"]:
                critical_limit = 18

        custom = "" if custom_roll_dice == "" else (" + " + custom_roll_dice)
        to_hit = " + " + request["to-hit"] + custom

        if request.advantage == RollType.DOUBLE:
            roll_1 = new Roll("1d20" + to_hit).roll()
            roll_2 = new Roll("1d20" + to_hit).roll()
            to_hit_roll = [roll_1, roll_2]
            is_critical = isCriticalHitD20(to_hit_roll, critical_limit)
        else:
            if request.advantage == RollType.NORMAL:
                dice = "1d20"
            elif request.advantage == RollType.ADVANTAGE:
                dice = "2d20kh"
            elif request.advantage == RollType.DISADVANTAGE:
                dice = "2d20kl"
            else:
                dice = "1d20" # TODO : Support dialog
            to_hit_roll = new Roll(dice + to_hit).roll()
            is_critical = isCriticalHitD20([to_hit_roll], critical_limit)
        rolls.append(("To Hit", to_hit_roll))

    if request.damages?:
        damages = list(request.damages)
        damage_types = list(request["damage-types"])
        total_damage = ""
        for i in range(damages.length):
            roll = new Roll(damages[i]).roll()
            total_damage += ("" if i == 0 else " + ") + str(roll.total)
            dmg_type = damage_types[i]
            suffix = " Damage" if dmg_type not in ["Healing", "Disciple of Life"] else ""
            rolls.append((dmg_type + suffix, roll))

    if is_critical and request["critical-damages"]?:
        damages = list(request["critical-damages"])
        damage_types = list(request["critical-damage-types"])
        total_critical_damage = ""
        for i in range(damages.length):
            roll = new Roll(damages[i]).roll()
            total_critical_damage += ("" if i == 0 else " + ") + str(roll.total)
            dmg_type = damage_types[i]
            suffix = " Critical Damage" if dmg_type not in ["Healing", "Disciple of Life"] else ""
            rolls.append((dmg_type + suffix, roll))

    if total_damage? and "+" in total_damage:
        rolls.append((None, "------"))
        rolls.append(("Total Damage", new Roll(total_damage).roll()))
        if total_critical_damage?:
            rolls.append(("Total Critical Damage", new Roll(total_critical_damage).roll()))

    return rolls

def rollAttack(request, custom_roll_dice=""):
    nonlocal settings

    rolls = buildAttackRolls(request, custom_roll_dice)

    data = {}
    if request.range?:
        data["Range"] = request.range

    if request["save-dc"]?:
        rolls.append(("Save", request["save-ability"] + " DC " + request["save-dc"]))

    # TODO: Support don't auto-roll dmg
    postDescription(request, request.name, None, data, request.description? "", rolls)


def buildSpellCard(request):
    data = {"Casting Time": request["casting-time"],
            "Range": request.range,
            "Duration": request.duration,
            "Components": request.components}

    if request["cast-at"]?:
        source = request["level-school"] + "(Cast at " + request["cast-at"] + " Level)"
    else:
        source = request["level-school"]
                                                    
    
    if request.ritual:
        data["Ritual"] = "Can be cast as a ritual"
    if request.concentration:
        data["Concentration"] = "Requires Concentration"
    description = request.description.replace("At Higher Levels.", "</br><b>At Higher levels.</b>")

    return (source, data, description)

def rollSpellCard(request):
    spell_card = buildSpellCard(request)
    postDescription(request, request.name, spell_card[0], spell_card[1], spell_card[2], open=True)

def rollSpellAttack(request, custom_roll_dice):
    nonlocal settings

    spell_card = buildSpellCard(request)

    rolls = []
    if request.range?:
        rolls.append(("Range", request.range))

    if request["cast-at"]?:
        rolls.append(("Cast at", request["cast-at"] + " Level"))
    components = request.components
    prefix = settings["component-prefix"] if settings["component-prefix"] != "" else None
    if settings["components-display"] == "all":
        if components != "":
            rolls.append((prefix or "Components", components))
    elif settings["components-display"] == "material":
        while components != "":
            if components[0] in ["V", "S"]:
                components = components[1:]
                if components.startsWith(", "):
                    components = components[2:]
            if components[0] == "M":
                rolls.append((prefix or "Materials", settings["component-prefix"] + components[2:-1]))
                components = ""

    if request["save-dc"]?:
        rolls.append(("Save", request["save-ability"] + " DC " + request["save-dc"]))

    rolls.extend(buildAttackRolls(request, custom_roll_dice))

    # TODO: Support don't auto-roll dmg
    postDescription(request, request.name, spell_card[0], spell_card[1], spell_card[2], rolls)

def handleRoll(request):
    nonlocal settings

    console.log("Received roll request ", request)

    custom_roll_dice = ""
    if request.character.type == "Character":
        custom_roll_dice = request.character.settings["custom-roll-dice"] ? ""
    if request.type == "skill":
        rollSkill(request, custom_roll_dice)
    elif request.type == "ability":
        rollAbility(request, custom_roll_dice)
    elif request.type == "saving-throw":
        rollSavingThrow(request, custom_roll_dice)
    elif request.type == "initiative":
        rollInitiative(request, custom_roll_dice)
    elif request.type == "hit-dice":
        rollHitDice(request)
    elif request.type in ["item", "feature", "trait", "action"]:
        rollTrait(request)
    elif request.type == "death-save":
        rollDeathSave(request, custom_roll_dice)
    elif request.type == "attack":
        rollAttack(request, custom_roll_dice)
    elif request.type == "spell-card":
        rollSpellCard(request)
    elif request.type == "spell-attack":
        rollSpellAttack(request, custom_roll_dice)
    else:
        # 'custom' or anything unexpected
        mod = request.modifier if request.modifier? else request.roll
        rname = request.name if request.name? else request.type

        rollDice(request, rname + "(" + mod + ")", mod, {})

def updateHP(name, current, total=None):
    console.log("Updating HP for " + name + " : " + current + "/" + total)
    name = name.toLowerCase()

    tokens = canvas.tokens.objects.children.filter(def(t): return t.data.name.toLowerCase() == name;)

    for token in tokens:
        if token.actor and token.data.actorLink:
            total = total if total else token.actor.data.attributes.hp.max
            token.actor.update({"data.attributes.hp.value" : current,
                                "data.attributes.hp.max" : total})
        else:
            if token.data.bar1.attribute == "attributes.hp":
                prefix = "bar1"
                total = total if total else token.data.bar1.max
            elif token.data.bar2.attribute == "attributes.hp":
                prefix = "bar2"
                total = total if total else token.data.bar2.max
            else:
                prefix = None
            if prefix:
                token.update(canvas.id, {prefix + ".value": current,
                                         prefix + ".max": total})
def setSettings(new_settings, url):
    nonlocal settings, extension_url
    settings = new_settings
    extension_url = url

def disconnectAllEvents():
    nonlocal registered_events
    
    for event in registered_events:
        document.removeEventListener(*event)

def setTitle():
    if game.world?:
        title = document.getElementsByTagName("title")[0]
        # Make sure the mutation gets triggerred if we reload the extension
        title.textContent = "Foundry Virtual Tabletop"
        title.textContent = game.world.name + " • Foundry Virtual Tabletop"
    else:
        # Wait a second for the world to get loaded
        setTimeout(setTitle, 1000)

console.log("Beyond20: FVTT Page Script loaded")
injectCSS(FVTT_CSS)
registered_events = []
registered_events.append(addCustomEventListener("Roll", handleRoll))
registered_events.append(addCustomEventListener("NewSettings", setSettings))
registered_events.append(addCustomEventListener("UpdateHP", updateHP))
registered_events.append(addCustomEventListener("disconnect", disconnectAllEvents))
setTitle()
