from utils import addCustomEventListener, injectCSS
from settings import WhisperType, RollType
from constants import TOOLTIP_CSS

settings = None

def getSpeakerByName(name):
    low_name = name.toLowerCase()
    actor = game.actors.entities.find(def(actor): return actor.data.name.toLowerCase() == low_name;)
    speaker = ChatMessage.getSpeaker({"actor": actor})
    speaker["alias"] = name
    return speaker

def postChatMessage(message, character=None, whisper=False):
    data = {"content": message, 
            "user": game.user._id,
            "speaker": getSpeakerByName(character)}
    if whisper:
        data["whisper"] = ChatMessage.getWhisperIDs("GM")
    return ChatMessage.create(data)

def whisperToRollMode(whisper):
    try:
        return {WhisperType.NO: "roll",
                WhisperType.YES: "gmroll",
                }[whisper]
    except:
        return game.settings.get("core", "rollMode")

def postDescription(request, title, source, attributes, description, rolls=[], open=False):
    style = "margin: 2px 0px; border: 1px solid #333; width: 100%; border-spacing: 0; border-collapse: collapse; background-color: #DDD;"

    html = "<details><summary><a><font style='color: #A00; font-size: 1.25em;'>" + title + "</font></a></summary>"
    if source or attributes.length > 0:
        html += "<table style='" + style + "'>"
        if source:
            html += "<tr><td colspan'2'><i>" + source + "</i></td></tr>"
        for attr in attributes:
            html += "<tr><td><b>" + attr + "</b></td><td>" + attributes[attr] + "</td></tr>"
        html += "</table>"
    html += "<div style='" + style + "'>" + description.replace("\n", "</br>") + "</div></details>"
    # TODO: handle 2d20kh1 where r.dice.rolls is more than 1 dice.
    # TODO: Support critical
    for (roll_name, roll) in rolls:
        roll_name = roll_name[0].toUpperCase() + roll_name[1:]
        if jstype(roll) == 'string':
            roll_html = "<span>" + roll + "</span>"
        else:
            roll_html = "<details style='display: inline;'><summary>" + roll.total + "</summary>" \
                "<span>" + roll.formula + " = " +  roll.result + "</span></details>"
        html += "<b>" + roll_name + ": </b>" + roll_html + "</br>"

    promise = postChatMessage(html, request.character.name, request.whisper == WhisperType.YES)
    if open:
        # FVTT 0.3.1 strips out the 'open' attribute, so we need to do it this way. Won't open it on everyone' log though
        promise.then(def(message):
                         console.log("Got a message : ", message)
                         setTimeout(def():$(".message[data-message-id=" + message.data._id + "] details").attr("open", "");, 0)
                     )

def rolldice(request, title, dice, data):
    rollMode = whisperToRollMode(request.whisper ? WhisperType.NO)
    new_data = {}
    parts = [dice]
    for key in data:
        if data[key] != "":
            new_key = key.replace("_", "").toLowerCase()
            new_data[new_key] = data[key]
            parts.append(new_key)
    roll = new Roll(parts.join(" + @"), new_data)

    roll.toMessage({"speaker": getSpeakerByName(request.character.name),
                    "flavor": title,
                    "rollMode": rollMode})
    return roll

def rolld20(request, title, data):
    if request.advantage == RollType.NORMAL:
        dice = "1d20"
    elif request.advantage == RollType.ADVANTAGE:
        dice = "2d20kh"
    elif request.advantage == RollType.DISADVANTAGE:
        dice = "2d20kl"
    elif request.advantage == RollType.DOUBLE:
        dice = "1d20"
        roll = rolldice(request, title, dice, data)
        rolldice(request, title, dice, data)
        return roll
    else:
        dice = "1d20" # TODO: query dialog

    return rolldice(request, title, dice, data)
    
def rollSkill(request, custom_roll_dice=""):
    data = {request.ability: request.modifier, "custom_dice": custom_roll_dice}
    # TODO: if modifier == "--": Query ability.
    rolld20(request, request.skill, data)

def rollAbility(request, custom_roll_dice=""): 
    data = {request.ability: request.modifier, "custom_dice": custom_roll_dice}
    if request["JoaT"]?:
        data["jack_of_all_trades"] = request["JoaT"]
    rolld20(request, request.name, data)

def rollSavingThrow(request, custom_roll_dice=""):
    data = {request.ability: request.modifier, "custom_dice": custom_roll_dice}
    rolld20(request, request.name + " Save", data)
  
def rollInitiative(request, custom_roll_dice=""):
    nonlocal settings

    data = {"initiative": request.initiative, "custom_dice": custom_roll_dice}
    roll = rolld20(request, "Initiative", data)

    if settings["initiative-tracker"] and canvas.tokens.controlledTokens.length > 0:
        token = canvas.tokens.controlledTokens[0]
        if game.combat?:
            game.combat.createCombatant({"tokenId": token.id, "hidden": token.data.hidden, "initiative": roll.total})
        else:
            ui.notifications.warn("Cannot add initiative to tracker: no Encounter has been created yet")

def rollHitDice(request):
    rname = "Hit Dice" + (("(" + request.class + ")") if  request.multiclass else "")
    rolldice(request, rname, request["hit-dice"], {})

def rollDeathSave(request, custom_roll_dice=""):
    rolld20(request, "Death Saving Throw", {"custom_dice": custom_roll_dice})

def rollTrait(request):
    if request["source-type"]?:
        source = request["source-type"]
        if request.source.length > 0:
            source += ": " + request.source
    elif request["item-type"]?:
        source = request["item-type"]
    else:
        source = request.type

    # TODO: Sub description
    postDescription(request, request.name, source, {}, request.description, open=True)


def rollAttack(request, custom_roll_dice=""):
    nonlocal settings

    rolls = []
    if request["to-hit"]?:
        # TODO: if advantage
        # TODO: super critical
        custom = "" if custom_roll_dice == "" else (" + " + custom_roll_dice)
        rolls.append(("To Hit", new Roll("1d20 + " + request["to-hit"] + custom).roll()))
    if request.damages?:
        damages = list(request.damages)
        damage_types = list(request["damage-types"])
        for i in range(damages.length):
            rolls.append((damage_types[i] + " Damage", new Roll(damages[i]).roll()))
    data = {}
    if request.range?:
        data["Range"] = request.range

    if request["save-dc"]?:
        rolls.append(("Save", request["save-ability"] + " DC " + request["save-dc"]))

    # TODO: Support don't auto-roll dmg
    postDescription(request, request.name, None, data, request.description? "", rolls)


def buildSpellCard(request):
    data = {"Casting Time": request["casting-time"],
            "Range": request.range,
            "Duration": request.duration,
            "Components": request.components}

    if request["cast-at"]?:
        source = request["level-school"] + "(Cast at " + request["cast-at"] + " Level)"
    else:
        source = request["level-school"]
                                                    
    
    if request.ritual:
        data["Ritual"] = "Can be cast as a ritual"
    if request.concentration:
        data["Concentration"] = "Requires Concentration"
    description = request.description.replace("At Higher Levels.", "</br><b>At Higher levels.</b>")

    return (source, data, description)

def rollSpellCard(request):
    spell_card = buildSpellCard(request)
    postDescription(request, request.name, spell_card[0], spell_card[1], spell_card[2], open=True)

def rollSpellAttack(request, custom_roll_dice):
    nonlocal settings

    spell_card = buildSpellCard(request)

    rolls = []
    if request["to-hit"]?:
        custom = "" if custom_roll_dice == "" else (" + " + custom_roll_dice)
        rolls.append(("To Hit", new Roll("1d20 + " + request["to-hit"] + custom).roll()))
    if request.damages?:
        # TODO: Handle Chromatic Orb
        for i in range(request.damages.length):
            dmg_type = request["damage-types"][i]
            rolls.append((dmg_type + (" Damage" if dmg_type != "Healing" else ""), new Roll(request.damages[i]).roll()))
    attributes = {}
    if request.range?:
        attributes["Range"] = request.range

    if request["save-dc"]?:
        rolls.append(("Save", request["save-ability"] + " DC " + request["save-dc"]))

    if request["cast-at"]?:
        rolls.append(("Cast at", request["cast-at"] + " Level"))
    components = request.components
    prefix = settings["component-prefix"] if settings["component-prefix"] != "" else None
    if settings["components-display"] == "all":
        if components != "":
            rolls.append((prefix or "Components", components))
    elif settings["components-display"] == "material":
        while components != "":
            if components[0] in ["V", "S"]:
                components = components[1:]
                if components.startsWith(", "):
                    components = components[2:]
            if components[0] == "M":
                rolls.append((prefix or "Materials", settings["component-prefix"] + components[2:-1]))
                components = ""

    # TODO: Support don't auto-roll dmg
    postDescription(request, request.name, spell_card[0], spell_card[1], spell_card[2], rolls)

def handleRoll(request):
    nonlocal settings

    console.log("Received roll request ", request)

    custom_roll_dice = ""
    if request.character.type == "Character":
        custom_roll_dice = request.character.settings["custom-roll-dice"] ? ""
    if request.type == "skill":
        rollSkill(request, custom_roll_dice)
    elif request.type == "ability":
        rollAbility(request, custom_roll_dice)
    elif request.type == "saving-throw":
        rollSavingThrow(request, custom_roll_dice)
    elif request.type == "initiative":
        rollInitiative(request, custom_roll_dice)
    elif request.type == "hit-dice":
        rollHitDice(request)
    elif request.type in ["item", "feature", "trait", "action"]:
        rollTrait(request)
    elif request.type == "death-save":
        rollDeathSave(request, custom_roll_dice)
    elif request.type == "attack":
        rollAttack(request, custom_roll_dice)
    elif request.type == "spell-card":
        rollSpellCard(request)
    elif request.type == "spell-attack":
        rollSpellAttack(request, custom_roll_dice)
    else:
        # 'custom' or anything unexpected
        mod = request.modifier if request.modifier? else request.roll
        rname = request.name if request.name? else request.type

        rolldice(request, rname + "(" + mod + ")", mod, {})

def updateHP(name, current, total=None):
    console.log("Updating HP for " + name + " : " + current + "/" + total)
    name = name.toLowerCase()

    tokens = canvas.tokens.objects.children.filter(def(t): return t.data.name.toLowerCase() == name;)

    for token in tokens:
        if token.actor and token.data.actorLink:
            total = total if total else token.actor.data.attributes.hp.max
            token.actor.update({"data.attributes.hp.value" : current,
                                "data.attributes.hp.max" : total})
        else:
            if token.data.bar1.attribute == "attributes.hp":
                prefix = "bar1"
                total = total if total else token.data.bar1.max
            elif token.data.bar2.attribute == "attributes.hp":
                prefix = "bar2"
                total = total if total else token.data.bar2.max
            else:
                prefix = None
            if prefix:
                token.update(canvas.id, {prefix + ".value": current,
                                         prefix + ".max": total})
def setSettings(new_settings):
    nonlocal settings
    settings = new_settings

def disconnectAllEvents():
    nonlocal registered_events
    
    for event in registered_events:
        document.removeEventListener(*event)

def setTitle():
    if game.world?:
        title = document.getElementsByTagName("title")[0]
        # Make sure the mutation gets triggerred if we reload the extension
        title.textContent = "Foundry Virtual Tabletop"
        title.textContent = game.world.name + " • Foundry Virtual Tabletop"
    else:
        # Wait a second for the world to get loaded
        setTimeout(setTitle, 1000)

console.log("Beyond20: FVTT Page Script loaded")
injectCSS(TOOLTIP_CSS)
registered_events = []
registered_events.append(addCustomEventListener("Roll", handleRoll))
registered_events.append(addCustomEventListener("NewSettings", setSettings))
registered_events.append(addCustomEventListener("UpdateHP", updateHP))
registered_events.append(addCustomEventListener("disconnect", disconnectAllEvents))
setTitle()
